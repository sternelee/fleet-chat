use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::collections::HashMap;

/// Request structure for generating a Fleet Chat plugin
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PluginGenerationRequest {
    /// Human-readable description of the plugin functionality
    pub description: String,

    /// Plugin name (will be sanitized for use in code)
    pub name: Option<String>,

    /// Plugin type (list, grid, detail, form)
    pub plugin_type: Option<String>,

    /// Additional context or requirements
    pub requirements: Option<Vec<String>>,

    /// Whether to use sample data
    pub include_sample_data: Option<bool>,

    /// User preferences for the plugin
    pub preferences: Option<HashMap<String, Value>>,
}

/// Response structure for generated plugin
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PluginGenerationResponse {
    /// Generated plugin manifest (package.json equivalent)
    pub manifest: PluginManifest,

    /// Generated plugin source code
    pub source_code: String,

    /// Generated plugin ID
    pub plugin_id: String,

    /// Plugin package name (.fcp file name)
    pub package_name: String,

    /// Explanation of what was generated
    pub explanation: String,

    /// Any warnings or recommendations
    pub warnings: Option<Vec<String>>,
}

/// Plugin manifest structure
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PluginManifest {
    pub name: String,
    pub version: String,
    pub description: String,
    pub author: String,
    pub icon: String,
    pub commands: Vec<PluginCommand>,
    pub categories: Option<Vec<String>>,
    pub preferences: Option<Vec<PluginPreference>>,
}

/// Plugin command definition
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PluginCommand {
    pub name: String,
    pub title: String,
    pub description: String,
    pub mode: String, // "view" or "no-view"
}

/// Plugin preference definition
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PluginPreference {
    pub name: String,
    #[serde(rename = "type")]
    pub pref_type: String,
    pub title: String,
    pub description: String,
    pub required: bool,
    pub default: Option<Value>,
}

/// Generate plugin code based on AI-generated specification
pub fn generate_plugin_code(
    manifest: &PluginManifest,
    plugin_type: &str,
    requirements: &[String],
    include_sample_data: bool,
) -> Result<String, String> {
    let plugin_name = &manifest.name;
    let plugin_description = &manifest.description;

    // Base imports - Using official Fleet Chat API
    let mut code = String::from(
        r#"/**
 * Auto-generated Fleet Chat Plugin
 * Generated by A2UI Plugin Generator
 * 
 * This plugin uses @fleet-chat/api for 100% Fleet Chat compatibility
 */

import { useState, useEffect } from 'lit/decorators.js';
import {
  List,
  ActionPanel,
  Action,
  Detail,
  Grid,
  Form,
  showToast,
  showHUD,
  Clipboard,
  LocalStorage,
  Cache,
  useNavigation,
  push,
  pop
} from '@fleet-chat/api';

"#,
    );

    // Generate component based on type
    match plugin_type {
        "list" => {
            code.push_str(&generate_list_component(
                plugin_name,
                plugin_description,
                requirements,
                include_sample_data,
            ));
        }
        "grid" => {
            code.push_str(&generate_grid_component(
                plugin_name,
                plugin_description,
                requirements,
                include_sample_data,
            ));
        }
        "detail" => {
            code.push_str(&generate_detail_component(
                plugin_name,
                plugin_description,
                requirements,
            ));
        }
        "form" => {
            code.push_str(&generate_form_component(plugin_name, plugin_description, requirements));
        }
        _ => {
            // Default to list view
            code.push_str(&generate_list_component(
                plugin_name,
                plugin_description,
                requirements,
                include_sample_data,
            ));
        }
    }

    Ok(code)
}

/// Generate a List-based plugin component with Fleet Chat API
fn generate_list_component(
    name: &str,
    description: &str,
    requirements: &[String],
    include_sample_data: bool,
) -> String {
    let sample_data = if include_sample_data {
        format!(
            r#"
  const [items, setItems] = useState([
    {{
      id: '1',
      title: 'Sample Item 1',
      subtitle: 'This is a sample item for {}',
      content: 'Content for item 1',
      icon: 'ðŸ“'
    }},
    {{
      id: '2',
      title: 'Sample Item 2',
      subtitle: 'Another example item',
      content: 'Content for item 2',
      icon: 'ðŸ“‹'
    }},
    {{
      id: '3',
      title: 'Sample Item 3',
      subtitle: 'Yet another item',
      content: 'Content for item 3',
      icon: 'âœ¨'
    }},
  ]);

  const [searchText, setSearchText] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  // Filter items based on search
  const filteredItems = items.filter(item =>
    item.title.toLowerCase().includes(searchText.toLowerCase()) ||
    (item.subtitle && item.subtitle.toLowerCase().includes(searchText.toLowerCase()))
  );
"#,
            name
        )
    } else {
        String::from(
            r#"
  const [items, setItems] = useState([]);
  const [searchText, setSearchText] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  // Load items from storage or API
  useEffect(() => {
    loadItems();
  }, []);

  async function loadItems() {
    setIsLoading(true);
    try {
      // TODO: Implement data loading logic
      const storedItems = await LocalStorage.getItem('items');
      if (storedItems) {
        setItems(JSON.parse(storedItems));
      }
    } catch (err) {
      setError(err as Error);
      await showToast({
        title: 'Error loading items',
        message: String(err),
        style: 'error'
      });
    } finally {
      setIsLoading(false);
    }
  }

  const filteredItems = items.filter(item =>
    item.title?.toLowerCase().includes(searchText.toLowerCase())
  );
"#,
        )
    };

    let requirements_comment = if !requirements.is_empty() {
        format!("// Requirements:\n// {}\n", requirements.join("\n// "))
    } else {
        String::new()
    };

    format!(
        r#"{}
/**
 * {} - Main Command
 * {}
 */
export default function Command() {{
{}
  return (
    <List
      isLoading={{isLoading}}
      searchText={{searchText}}
      onSearchTextChange={{setSearchText}}
      navigationTitle="{}"
    >
      {{filteredItems.map((item) => (
        <List.Item
          key={{item.id}}
          title={{item.title}}
          subtitle={{item.subtitle}}
          icon={{item.icon || 'ðŸ“„'}}
          accessories={{[
            {{ text: item.content }}
          ]}}
          actions={{
            <ActionPanel>
              <Action
                title="View Details"
                onAction={{async () => {{
                  await showToast({{
                    title: 'Item Selected',
                    message: item.title,
                    style: 'success'
                  }});
                }}}}
              />
              <Action.CopyToClipboard
                title="Copy to Clipboard"
                content={{item.content || item.title}}
              />
              <Action
                title="Save to Storage"
                onAction={{async () => {{
                  await LocalStorage.setItem(`item-${{item.id}}`, JSON.stringify(item));
                  await showToast({{
                    title: 'Saved',
                    message: 'Item saved to local storage',
                    style: 'success'
                  }});
                }}}}
              />
            </ActionPanel>
          }}
        />
      ))}}
    </List>
  );
}}
"#,
        requirements_comment, name, description, sample_data, name
    )
}

/// Generate a Grid-based plugin component with Fleet Chat API
fn generate_grid_component(
    name: &str,
    description: &str,
    requirements: &[String],
    include_sample_data: bool,
) -> String {
    let sample_data = if include_sample_data {
        String::from(
            r#"
  const [items, setItems] = useState([
    { id: '1', title: 'Item 1', subtitle: 'Description 1', content: 'Content 1', imageUrl: 'https://via.placeholder.com/300' },
    { id: '2', title: 'Item 2', subtitle: 'Description 2', content: 'Content 2', imageUrl: 'https://via.placeholder.com/300' },
    { id: '3', title: 'Item 3', subtitle: 'Description 3', content: 'Content 3', imageUrl: 'https://via.placeholder.com/300' },
    { id: '4', title: 'Item 4', subtitle: 'Description 4', content: 'Content 4', imageUrl: 'https://via.placeholder.com/300' },
  ]);
  const [isLoading, setIsLoading] = useState(false);
"#,
        )
    } else {
        String::from(
            r#"
  const [items, setItems] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  
  useEffect(() => {
    async function loadItems() {
      setIsLoading(true);
      try {
        // TODO: Load items from API or storage
        const storedItems = await LocalStorage.getItem('grid-items');
        if (storedItems) {
          setItems(JSON.parse(storedItems));
        }
      } catch (error) {
        await showToast({
          title: 'Error loading items',
          message: String(error),
          style: 'error'
        });
      } finally {
        setIsLoading(false);
      }
    }
    loadItems();
  }, []);
"#,
        )
    };

    let requirements_comment = if !requirements.is_empty() {
        format!("// Requirements:\n// {}\n", requirements.join("\n// "))
    } else {
        String::new()
    };

    format!(
        r#"{}
/**
 * {} - Main Command
 * {}
 */
export default function Command() {{
{}
  return (
    <Grid
      columns={{3}}
      isLoading={{isLoading}}
      navigationTitle="{}"
    >
      {{items.map((item) => (
        <Grid.Item
          key={{item.id}}
          title={{item.title}}
          subtitle={{item.subtitle}}
          content={{{{ source: item.imageUrl || 'https://via.placeholder.com/300' }}}}
          actions={{
            <ActionPanel>
              <Action
                title="View Details"
                onAction={{async () => {{
                  await showToast({{
                    title: 'Item Selected',
                    message: item.title,
                    style: 'success'
                  }});
                }}}}
              />
              <Action.CopyToClipboard
                title="Copy Title"
                content={{item.title}}
              />
              <Action.OpenInBrowser
                title="Open Image"
                url={{item.imageUrl}}
              />
            </ActionPanel>
          }}
        />
      ))}}
    </Grid>
  );
}}
"#,
        requirements_comment, name, description, sample_data, name
    )
}

/// Generate a Detail-based plugin component with Fleet Chat API
fn generate_detail_component(name: &str, description: &str, requirements: &[String]) -> String {
    let requirements_comment = if !requirements.is_empty() {
        format!("// Requirements:\n// {}\n", requirements.join("\n// "))
    } else {
        String::new()
    };

    format!(
        r#"{}
/**
 * {} - Main Command
 * {}
 */
export default function Command() {{
  const [content, setContent] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  useEffect(() => {{
    async function loadContent() {{
      setIsLoading(true);
      try {{
        // TODO: Load content from API or storage
        const stored = await LocalStorage.getItem('detail-content');
        if (stored) {{
          setContent(stored);
        }}
      }} catch (error) {{
        await showToast({{
          title: 'Error loading content',
          message: String(error),
          style: 'error'
        }});
      }} finally {{
        setIsLoading(false);
      }}
    }}
    loadContent();
  }}, []);

  const markdown = `
# {}

{}

## Features

- Display detailed information with markdown
- Rich text formatting support  
- Code blocks and syntax highlighting
- Tables and lists

## Usage

This plugin provides a detailed information view.
You can customize the content by:

1. Loading data from an API
2. Fetching from local storage
3. Processing user input

## Example Code

\`\`\`typescript
const data = await fetchData();
setContent(data);
\`\`\`

## Next Steps

- Customize the markdown content
- Add metadata sections
- Integrate with external data sources
  `;

  return (
    <Detail
      markdown={{markdown || content}}
      isLoading={{isLoading}}
      navigationTitle="{}"
      metadata={{
        <Detail.Metadata>
          <Detail.Metadata.Label
            title="Created"
            text={{new Date().toLocaleDateString()}}
          />
          <Detail.Metadata.Separator />
          <Detail.Metadata.Label
            title="Type"
            text="Detail View"
          />
        </Detail.Metadata>
      }}
      actions={{
        <ActionPanel>
          <Action.CopyToClipboard
            title="Copy Content"
            content={{markdown || content}}
          />
          <Action
            title="Refresh"
            onAction={{async () => {{
              setIsLoading(true);
              // Reload content
              setIsLoading(false);
              await showToast({{
                title: 'Refreshed',
                style: 'success'
              }});
            }}}}
          />
        </ActionPanel>
      }}
    />
  );
}}
"#,
        requirements_comment, name, description, name, description, name
    )
}

/// Generate a Form-based plugin component with Fleet Chat API
fn generate_form_component(name: &str, description: &str, requirements: &[String]) -> String {
    let requirements_comment = if !requirements.is_empty() {
        format!("// Requirements:\n// {}\n", requirements.join("\n// "))
    } else {
        String::new()
    };

    format!(
        r#"{}
/**
 * {} - Main Command
 * {}
 */
interface FormValues {{
  name: string;
  email: string;
  message: string;
  category: string;
  subscribe: boolean;
}}

export default function Command() {{
  const [isSubmitting, setIsSubmitting] = useState(false);

  async function handleSubmit(values: FormValues) {{
    setIsSubmitting(true);
    try {{
      // TODO: Process form submission (e.g., API call, save to storage)
      console.log('Form submitted:', values);
      
      // Save to local storage
      await LocalStorage.setItem('lastSubmission', JSON.stringify({{
        ...values,
        timestamp: new Date().toISOString()
      }}));
      
      await showToast({{
        title: 'Form Submitted',
        message: `Thank you, ${{values.name}}!`,
        style: 'success'
      }});
      
      // Optional: Navigate to a success view
      // push(<SuccessView />);
      
    }} catch (error) {{
      await showToast({{
        title: 'Submission Error',
        message: String(error),
        style: 'error'
      }});
    }} finally {{
      setIsSubmitting(false);
    }}
  }}

  return (
    <Form
      isLoading={{isSubmitting}}
      navigationTitle="{}"
      actions={{
        <ActionPanel>
          <Action.SubmitForm
            title="Submit"
            onSubmit={{handleSubmit}}
          />
          <Action
            title="Clear Form"
            onAction={{async () => {{
              // Form will be reset automatically
              await showToast({{
                title: 'Form Cleared',
                style: 'success'
              }});
            }}}}
          />
        </ActionPanel>
      }}
    >
      <Form.TextField
        id="name"
        title="Name"
        placeholder="Enter your name"
        info="Your full name"
      />
      <Form.TextField
        id="email"
        title="Email"
        placeholder="your.email@example.com"
        info="We'll never share your email"
      />
      <Form.TextArea
        id="message"
        title="Message"
        placeholder="Enter your message..."
        info="Tell us what's on your mind"
      />
      <Form.Dropdown
        id="category"
        title="Category"
        defaultValue="general"
        info="Select a category for your message"
      >
        <Form.Dropdown.Item value="general" title="General Inquiry" />
        <Form.Dropdown.Item value="support" title="Technical Support" />
        <Form.Dropdown.Item value="feedback" title="Feedback" />
        <Form.Dropdown.Item value="other" title="Other" />
      </Form.Dropdown>
      <Form.Checkbox
        id="subscribe"
        label="Subscribe to newsletter"
        defaultValue={{false}}
        info="Get updates and news"
      />
      <Form.Separator />
      <Form.Description
        title="Privacy Notice"
        text="Your information will be handled according to our privacy policy."
      />
    </Form>
  );
}}
"#,
        requirements_comment, name, description, name
    )
}

/// Sanitize plugin name for use in code
pub fn sanitize_plugin_name(name: &str) -> String {
    name.trim()
        .to_lowercase()
        .replace(|c: char| !c.is_alphanumeric() && c != '-' && c != '_', "-")
        .replace("--", "-")
        .trim_matches('-')
        .to_string()
}

/// Generate a default manifest for a plugin
pub fn generate_default_manifest(name: &str, description: &str, plugin_type: &str) -> PluginManifest {
    let sanitized_name = sanitize_plugin_name(name);

    PluginManifest {
        name: sanitized_name.clone(),
        version: "1.0.0".to_string(),
        description: description.to_string(),
        author: "A2UI Plugin Generator".to_string(),
        icon: match plugin_type {
            "list" => "ðŸ“‹",
            "grid" => "ðŸŽ¯",
            "detail" => "ðŸ“„",
            "form" => "ðŸ“",
            _ => "ðŸ”Œ",
        }
        .to_string(),
        commands: vec![PluginCommand {
            name: "default".to_string(),
            title: name.to_string(),
            description: description.to_string(),
            mode: "view".to_string(),
        }],
        categories: Some(vec!["Productivity".to_string()]),
        preferences: None,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sanitize_plugin_name() {
        assert_eq!(sanitize_plugin_name("My Plugin"), "my-plugin");
        assert_eq!(sanitize_plugin_name("Test@Plugin!"), "test-plugin");
        assert_eq!(sanitize_plugin_name("  spaced  "), "spaced");
    }

    #[test]
    fn test_generate_default_manifest() {
        let manifest = generate_default_manifest("Test Plugin", "A test plugin", "list");
        assert_eq!(manifest.name, "test-plugin");
        assert_eq!(manifest.version, "1.0.0");
        assert_eq!(manifest.icon, "ðŸ“‹");
    }
}
