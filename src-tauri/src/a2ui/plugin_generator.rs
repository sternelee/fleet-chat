use serde::{Deserialize, Serialize};
use serde_json::{json, Value};
use std::collections::HashMap;

/// Request structure for generating a Fleet Chat plugin
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PluginGenerationRequest {
    /// Human-readable description of the plugin functionality
    pub description: String,

    /// Plugin name (will be sanitized for use in code)
    pub name: Option<String>,

    /// Plugin type (list, grid, detail, form)
    pub plugin_type: Option<String>,

    /// Additional context or requirements
    pub requirements: Option<Vec<String>>,

    /// Whether to use sample data
    pub include_sample_data: Option<bool>,

    /// User preferences for the plugin
    pub preferences: Option<HashMap<String, Value>>,
}

/// Response structure for generated plugin
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PluginGenerationResponse {
    /// Generated plugin manifest (package.json equivalent)
    pub manifest: PluginManifest,

    /// Generated plugin source code
    pub source_code: String,

    /// Generated plugin ID
    pub plugin_id: String,

    /// Plugin package name (.fcp file name)
    pub package_name: String,

    /// Explanation of what was generated
    pub explanation: String,

    /// Any warnings or recommendations
    pub warnings: Option<Vec<String>>,
}

/// Plugin manifest structure
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PluginManifest {
    pub name: String,
    pub version: String,
    pub description: String,
    pub author: String,
    pub icon: String,
    pub commands: Vec<PluginCommand>,
    pub categories: Option<Vec<String>>,
    pub preferences: Option<Vec<PluginPreference>>,
}

/// Plugin command definition
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PluginCommand {
    pub name: String,
    pub title: String,
    pub description: String,
    pub mode: String, // "view" or "no-view"
}

/// Plugin preference definition
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PluginPreference {
    pub name: String,
    #[serde(rename = "type")]
    pub pref_type: String,
    pub title: String,
    pub description: String,
    pub required: bool,
    pub default: Option<Value>,
}

/// Generate plugin code based on AI-generated specification
pub fn generate_plugin_code(
    manifest: &PluginManifest,
    plugin_type: &str,
    requirements: &[String],
    include_sample_data: bool,
) -> Result<String, String> {
    let plugin_name = &manifest.name;
    let plugin_description = &manifest.description;

    // Base imports
    let mut code = String::from(
        r#"/**
 * Auto-generated Fleet Chat Plugin
 * Generated by A2UI Plugin Generator
 */

import React, { useState, useEffect } from 'react';
import {
  List,
  ActionPanel,
  Action,
  Detail,
  Grid,
  Form,
  showToast,
  Clipboard,
  LocalStorage,
  Cache
} from '@fleet-chat/raycast-api';

"#,
    );

    // Generate component based on type
    match plugin_type {
        "list" => {
            code.push_str(&generate_list_component(
                plugin_name,
                plugin_description,
                requirements,
                include_sample_data,
            ));
        }
        "grid" => {
            code.push_str(&generate_grid_component(
                plugin_name,
                plugin_description,
                requirements,
                include_sample_data,
            ));
        }
        "detail" => {
            code.push_str(&generate_detail_component(
                plugin_name,
                plugin_description,
                requirements,
            ));
        }
        "form" => {
            code.push_str(&generate_form_component(plugin_name, plugin_description, requirements));
        }
        _ => {
            // Default to list view
            code.push_str(&generate_list_component(
                plugin_name,
                plugin_description,
                requirements,
                include_sample_data,
            ));
        }
    }

    Ok(code)
}

/// Generate a List-based plugin component
fn generate_list_component(
    name: &str,
    description: &str,
    requirements: &[String],
    include_sample_data: bool,
) -> String {
    let sample_data = if include_sample_data {
        format!(
            r#"
  const [items, setItems] = useState([
    {{
      id: '1',
      title: 'Sample Item 1',
      subtitle: 'This is a sample item for {}',
      content: 'Content for item 1',
    }},
    {{
      id: '2',
      title: 'Sample Item 2',
      subtitle: 'Another example item',
      content: 'Content for item 2',
    }},
    {{
      id: '3',
      title: 'Sample Item 3',
      subtitle: 'Yet another item',
      content: 'Content for item 3',
    }},
  ]);

  const [searchText, setSearchText] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  // Filter items based on search
  const filteredItems = items.filter(item =>
    item.title.toLowerCase().includes(searchText.toLowerCase()) ||
    item.subtitle.toLowerCase().includes(searchText.toLowerCase())
  );
"#,
            name
        )
    } else {
        format!(
            r#"
  const [items, setItems] = useState([]);
  const [searchText, setSearchText] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  // Load items from storage or API
  useEffect(() => {{
    loadItems();
  }}, []);

  async function loadItems() {{
    setIsLoading(true);
    try {{
      // TODO: Implement data loading logic
      const storedItems = await LocalStorage.getItem('items');
      if (storedItems) {{
        setItems(JSON.parse(storedItems));
      }}
    }} catch (error) {{
      await showToast({{
        title: 'Error loading items',
        message: String(error),
      }});
    }} finally {{
      setIsLoading(false);
    }}
  }}

  const filteredItems = items.filter(item =>
    item.title?.toLowerCase().includes(searchText.toLowerCase())
  );
"#
        )
    };

    let requirements_comment = if !requirements.is_empty() {
        format!("// Requirements:\n// {}\n", requirements.join("\n// "))
    } else {
        String::new()
    };

    format!(
        r#"{}
/**
 * {} - Main Command
 * {}
 */
export default function Command() {{
{}
  return (
    <List
      isLoading={{isLoading}}
      searchText={{searchText}}
      onSearchTextChange={{setSearchText}}
      navigationTitle="{}"
    >
      {{filteredItems.map((item) => (
        <List.Item
          key={{item.id}}
          title={{item.title}}
          subtitle={{item.subtitle}}
          actions={{
            <ActionPanel>
              <Action
                title="View Details"
                onAction={{async () => {{
                  await showToast({{
                    title: 'Item Selected',
                    message: item.title,
                  }});
                }}}}
              />
              <Action
                title="Copy to Clipboard"
                onAction={{async () => {{
                  await Clipboard.copy(item.content || item.title);
                  await showToast({{
                    title: 'Copied',
                    message: 'Item copied to clipboard',
                  }});
                }}}}
              />
              <Action
                title="Save to Storage"
                onAction={{async () => {{
                  await LocalStorage.setItem(`item-${{item.id}}`, JSON.stringify(item));
                  await showToast({{
                    title: 'Saved',
                    message: 'Item saved to local storage',
                  }});
                }}}}
              />
            </ActionPanel>
          }}
        />
      ))}}
    </List>
  );
}}
"#,
        requirements_comment, name, description, sample_data, name
    )
}

/// Generate a Grid-based plugin component
fn generate_grid_component(
    name: &str,
    description: &str,
    requirements: &[String],
    include_sample_data: bool,
) -> String {
    let sample_data = if include_sample_data {
        format!(
            r#"
  const [items, setItems] = useState([
    {{ id: '1', title: 'Item 1', content: 'Content 1', imageUrl: '' }},
    {{ id: '2', title: 'Item 2', content: 'Content 2', imageUrl: '' }},
    {{ id: '3', title: 'Item 3', content: 'Content 3', imageUrl: '' }},
    {{ id: '4', title: 'Item 4', content: 'Content 4', imageUrl: '' }},
  ]);
"#
        )
    } else {
        String::from(
            r#"
  const [items, setItems] = useState([]);
  
  useEffect(() => {
    // TODO: Load items
  }, []);
"#,
        )
    };

    let requirements_comment = if !requirements.is_empty() {
        format!("// Requirements:\n// {}\n", requirements.join("\n// "))
    } else {
        String::new()
    };

    format!(
        r#"{}
/**
 * {} - Main Command
 * {}
 */
export default function Command() {{
{}
  return (
    <Grid>
      {{items.map((item) => (
        <Grid.Item
          key={{item.id}}
          title={{item.title}}
          content={{{{ source: item.imageUrl || '' }}}}
          actions={{
            <ActionPanel>
              <Action
                title="View"
                onAction={{async () => {{
                  await showToast({{
                    title: 'Item Selected',
                    message: item.title,
                  }});
                }}}}
              />
            </ActionPanel>
          }}
        />
      ))}}
    </Grid>
  );
}}
"#,
        requirements_comment, name, description, sample_data
    )
}

/// Generate a Detail-based plugin component
fn generate_detail_component(name: &str, description: &str, requirements: &[String]) -> String {
    let requirements_comment = if !requirements.is_empty() {
        format!("// Requirements:\n// {}\n", requirements.join("\n// "))
    } else {
        String::new()
    };

    format!(
        r#"{}
/**
 * {} - Main Command
 * {}
 */
export default function Command() {{
  const markdown = `
# {}

{}

## Features

- Display detailed information
- Markdown support
- Rich formatting

## Usage

This plugin provides detailed information view.
Replace this content with your actual data.
  `;

  return (
    <Detail
      markdown={{markdown}}
      actions={{
        <ActionPanel>
          <Action
            title="Copy Content"
            onAction={{async () => {{
              await Clipboard.copy(markdown);
              await showToast({{
                title: 'Copied',
                message: 'Content copied to clipboard',
              }});
            }}}}
          />
        </ActionPanel>
      }}
    />
  );
}}
"#,
        requirements_comment, name, description, name, description
    )
}

/// Generate a Form-based plugin component
fn generate_form_component(name: &str, description: &str, requirements: &[String]) -> String {
    let requirements_comment = if !requirements.is_empty() {
        format!("// Requirements:\n// {}\n", requirements.join("\n// "))
    } else {
        String::new()
    };

    format!(
        r#"{}
/**
 * {} - Main Command
 * {}
 */
export default function Command() {{
  const [formData, setFormData] = useState({{
    name: '',
    email: '',
    message: '',
  }});

  async function handleSubmit(values: typeof formData) {{
    try {{
      // TODO: Process form submission
      await showToast({{
        title: 'Form Submitted',
        message: `Submitted: ${{values.name}}`,
      }});
      
      // Save to storage
      await LocalStorage.setItem('lastSubmission', JSON.stringify(values));
    }} catch (error) {{
      await showToast({{
        title: 'Error',
        message: String(error),
      }});
    }}
  }}

  return (
    <Form
      actions={{
        <ActionPanel>
          <Action.SubmitForm
            title="Submit"
            onSubmit={{handleSubmit}}
          />
        </ActionPanel>
      }}
    >
      <Form.TextField
        id="name"
        title="Name"
        placeholder="Enter your name"
      />
      <Form.TextField
        id="email"
        title="Email"
        placeholder="Enter your email"
      />
      <Form.TextArea
        id="message"
        title="Message"
        placeholder="Enter your message"
      />
    </Form>
  );
}}
"#,
        requirements_comment, name, description
    )
}

/// Sanitize plugin name for use in code
pub fn sanitize_plugin_name(name: &str) -> String {
    name.trim()
        .to_lowercase()
        .replace(|c: char| !c.is_alphanumeric() && c != '-' && c != '_', "-")
        .replace("--", "-")
        .trim_matches('-')
        .to_string()
}

/// Generate a default manifest for a plugin
pub fn generate_default_manifest(name: &str, description: &str, plugin_type: &str) -> PluginManifest {
    let sanitized_name = sanitize_plugin_name(name);

    PluginManifest {
        name: sanitized_name.clone(),
        version: "1.0.0".to_string(),
        description: description.to_string(),
        author: "A2UI Plugin Generator".to_string(),
        icon: match plugin_type {
            "list" => "ðŸ“‹",
            "grid" => "ðŸŽ¯",
            "detail" => "ðŸ“„",
            "form" => "ðŸ“",
            _ => "ðŸ”Œ",
        }
        .to_string(),
        commands: vec![PluginCommand {
            name: "default".to_string(),
            title: name.to_string(),
            description: description.to_string(),
            mode: "view".to_string(),
        }],
        categories: Some(vec!["Productivity".to_string()]),
        preferences: None,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sanitize_plugin_name() {
        assert_eq!(sanitize_plugin_name("My Plugin"), "my-plugin");
        assert_eq!(sanitize_plugin_name("Test@Plugin!"), "test-plugin");
        assert_eq!(sanitize_plugin_name("  spaced  "), "spaced");
    }

    #[test]
    fn test_generate_default_manifest() {
        let manifest = generate_default_manifest("Test Plugin", "A test plugin", "list");
        assert_eq!(manifest.name, "test-plugin");
        assert_eq!(manifest.version, "1.0.0");
        assert_eq!(manifest.icon, "ðŸ“‹");
    }
}
